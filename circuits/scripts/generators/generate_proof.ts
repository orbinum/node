#!/usr/bin/env ts-node
/**
 * Script to generate a sample Groth16 proof for the transfer circuit.
 * This demonstrates the end-to-end flow from inputs to proof.
 */

import { buildPoseidon, buildEddsa, buildBabyjub } from 'circomlibjs';
import * as snarkjs from 'snarkjs';
import * as fs from 'fs';
import * as path from 'path';

interface InputNote {
    value: bigint;
    asset_id: bigint;
    owner_pubkey: bigint;
    blinding: bigint;
    spending_key: bigint;
}

interface OutputNote {
    value: bigint;
    asset_id: bigint;
    owner_pubkey: bigint;
    blinding: bigint;
}

interface CircuitInput {
    merkle_root: string;
    nullifiers: string[];
    commitments: string[];
    input_values: string[];
    input_asset_ids: string[];
    // input_owner_pubkeys eliminado, ahora usamos input_owner_Ax y input_owner_Ay
    input_blindings: string[];
    spending_keys: string[];
    input_path_elements: string[][];
    input_path_indices: number[][];
    output_values: string[];
    output_asset_ids: string[];
    output_owner_pubkeys: string[];
    output_blindings: string[];
    [key: string]: any;
}

interface SubstrateProof {
    a: {
        x: string;
        y: string;
    };
    b: {
        x: string[];
        y: string[];
    };
    c: {
        x: string;
        y: string;
    };
}

// Utility to convert Poseidon output to BigInt string
const poseidonToStr = (poseidon: any, hash: any): string => poseidon.F.toString(hash);

const MERKLE_TREE_DEPTH = 20;

async function main(): Promise<void> {
    console.log("=== Transfer Proof Generator ===\n");

    // Load existing input.json generated by gen-input:transfer
    const inputPath = path.join(__dirname, '../../build/input.json');
    
    if (!fs.existsSync(inputPath)) {
        console.error("❌ Error: input.json not found!");
        console.error("Please run 'npm run gen-input:transfer' first to generate the input.");
        process.exit(1);
    }

    console.log("1. Loading input from build/input.json...");
    const input = JSON.parse(fs.readFileSync(inputPath, 'utf-8'));

    console.log("   ✓ Input loaded successfully");
    console.log("   Merkle Root:", input.merkle_root.slice(0, 20) + "...");
    console.log("   Nullifiers:", input.nullifiers.length);
    console.log("   Commitments:", input.commitments.length);

    console.log("\n2. Generating ZK proof (this may take a moment)...");

    try {
        const { proof, publicSignals } = await snarkjs.groth16.fullProve(
            input,
            path.join(__dirname, '../../build/transfer_js/transfer.wasm'),
            path.join(__dirname, '../../keys/transfer_pk.zkey')
        );

        console.log("\n✓ Proof generated successfully!");

        console.log("\n3. Verifying proof...");
        const vKeyPath = path.join(__dirname, '../../build/verification_key_transfer.json');
        const vKey = JSON.parse(fs.readFileSync(vKeyPath, 'utf-8'));

        const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);

        if (isValid) {
            console.log("✓ Proof verification PASSED!");
        } else {
            console.log("✗ Proof verification FAILED!");
            process.exit(1);
        }

        console.log("\n4. Saving proof output...");
        const proofPath = path.join(__dirname, '../../build/proof.json');
        const publicPath = path.join(__dirname, '../../build/public.json');
        
        fs.writeFileSync(proofPath, JSON.stringify(proof, null, 2));
        fs.writeFileSync(publicPath, JSON.stringify(publicSignals, null, 2));
        
        console.log("   ✓ Proof saved to build/proof.json");
        console.log("   ✓ Public signals saved to build/public.json");

        console.log("\n=== DONE ===");
        console.log("Proof generation and verification completed successfully!");

    } catch (err) {
        console.error("\n✗ Error generating proof:", (err as Error).message);
        process.exit(1);
    }
}

main();
