//! Snarkjs format parser
//!
//! This module provides utilities to parse proofs and public inputs from
//! the JSON format generated by snarkjs (the tool used to compile Circom circuits).

#[cfg(feature = "std")]
use crate::domain::value_objects::{
	errors::VerifierError,
	proof_types::{Proof, PublicInputs},
};

#[cfg(feature = "std")]
use {
	ark_bn254::{Fq, Fq2, G1Affine, G2Affine},
	ark_ff::PrimeField,
	ark_groth16::Proof as ArkProof,
	num_bigint::BigUint,
};

/// Snarkjs proof points as separate coordinate strings
pub struct SnarkjsProofPoints<'a> {
	pub a_x: &'a str,
	pub a_y: &'a str,
	pub b_x0: &'a str,
	pub b_x1: &'a str,
	pub b_y0: &'a str,
	pub b_y1: &'a str,
	pub c_x: &'a str,
	pub c_y: &'a str,
}

/// Parse a proof from snarkjs JSON format
///
/// The snarkjs format looks like:
/// ```json
/// {
///   "a": { "x": "...", "y": "..." },
///   "b": { "x": ["...", "..."], "y": ["...", "..."] },
///   "c": { "x": "...", "y": "..." }
/// }
/// ```
#[cfg(feature = "std")]
pub fn parse_proof_from_snarkjs(points: SnarkjsProofPoints) -> Result<Proof, VerifierError> {
	use ark_bn254::Bn254;

	// Parse point A (G1)
	let a = G1Affine::new(parse_fq(points.a_x), parse_fq(points.a_y));

	// Parse point B (G2)
	// Note: snarkjs uses (x0, x1) order but arkworks might use (c1, c0)
	// We need to check the convention
	let b = G2Affine::new(
		Fq2::new(parse_fq(points.b_x0), parse_fq(points.b_x1)),
		Fq2::new(parse_fq(points.b_y0), parse_fq(points.b_y1)),
	);

	// Parse point C (G1)
	let c = G1Affine::new(parse_fq(points.c_x), parse_fq(points.c_y));

	// Create arkworks proof
	let ark_proof = ArkProof::<Bn254> { a, b, c };

	// Convert to our Proof type
	Proof::from_ark_proof(&ark_proof)
}

/// Parse public inputs from snarkjs JSON format
///
/// The format is an array of field element strings:
/// ```json
/// ["123...", "456...", ...]
/// ```
#[cfg(feature = "std")]
pub fn parse_public_inputs_from_snarkjs(
	input_strings: &[&str],
) -> Result<PublicInputs, VerifierError> {
	use ark_ff::{BigInteger, PrimeField};

	let inputs: Result<Vec<_>, _> = input_strings
		.iter()
		.map(|s| {
			let field = parse_fr(s);

			// Convert to bytes (big-endian)
			let mut bytes = [0u8; 32];
			let elem_bytes = field.into_bigint().to_bytes_be();
			let start = 32 - elem_bytes.len();
			bytes[start..].copy_from_slice(&elem_bytes);

			Ok(bytes)
		})
		.collect();

	Ok(PublicInputs::new(inputs?))
}

#[cfg(feature = "std")]
fn parse_fq(s: &str) -> Fq {
	let bigint = BigUint::parse_bytes(s.as_bytes(), 10).expect("Invalid field element string");

	let bytes = bigint.to_bytes_le();
	let mut bytes_32 = [0u8; 32];
	bytes_32[..bytes.len().min(32)].copy_from_slice(&bytes[..bytes.len().min(32)]);

	Fq::from_le_bytes_mod_order(&bytes_32)
}

#[cfg(feature = "std")]
fn parse_fr(s: &str) -> ark_bn254::Fr {
	let bigint = BigUint::parse_bytes(s.as_bytes(), 10).expect("Invalid field element string");

	let bytes = bigint.to_bytes_le();
	let mut bytes_32 = [0u8; 32];
	bytes_32[..bytes.len().min(32)].copy_from_slice(&bytes[..bytes.len().min(32)]);

	ark_bn254::Fr::from_le_bytes_mod_order(&bytes_32)
}

#[cfg(all(test, feature = "std"))]
mod tests {
	use super::*;

	// === parse_public_inputs_from_snarkjs Tests ===

	#[test]
	fn test_parse_public_inputs_valid_small_values() {
		let input_strings = ["123", "456", "789"];
		let result = parse_public_inputs_from_snarkjs(&input_strings);
		assert!(result.is_ok(), "Should parse valid inputs");

		let inputs = result.unwrap();
		assert_eq!(inputs.len(), 3);
	}

	#[test]
	fn test_parse_public_inputs_single_value() {
		let input_strings = ["42"];
		let result = parse_public_inputs_from_snarkjs(&input_strings);
		assert!(result.is_ok());

		let inputs = result.unwrap();
		assert_eq!(inputs.len(), 1);
	}

	#[test]
	fn test_parse_public_inputs_empty() {
		let input_strings: [&str; 0] = [];
		let result = parse_public_inputs_from_snarkjs(&input_strings);
		assert!(result.is_ok());

		let inputs = result.unwrap();
		assert_eq!(inputs.len(), 0);
		assert!(inputs.is_empty());
	}

	#[test]
	fn test_parse_public_inputs_large_values() {
		let input_strings = [
			"1000000000000000000000",
			"21888242871839275222246405745257275088548364400416034343698204186575808495617",
		];
		let result = parse_public_inputs_from_snarkjs(&input_strings);
		assert!(result.is_ok(), "Should parse large valid values");

		let inputs = result.unwrap();
		assert_eq!(inputs.len(), 2);
	}

	#[test]
	fn test_parse_public_inputs_zero() {
		let input_strings = ["0"];
		let result = parse_public_inputs_from_snarkjs(&input_strings);
		assert!(result.is_ok());

		let inputs = result.unwrap();
		assert_eq!(inputs.len(), 1);
	}

	#[test]
	fn test_parse_public_inputs_many_inputs() {
		let input_strings: Vec<&str> = (0..32).map(|_| "123").collect();
		let result = parse_public_inputs_from_snarkjs(&input_strings);
		assert!(result.is_ok());

		let inputs = result.unwrap();
		assert_eq!(inputs.len(), 32);
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_public_inputs_invalid_string() {
		let input_strings = ["not_a_number", "123"];
		let _ = parse_public_inputs_from_snarkjs(&input_strings);
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_public_inputs_negative_number() {
		let input_strings = ["-123"];
		let _ = parse_public_inputs_from_snarkjs(&input_strings);
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_public_inputs_hex_without_prefix() {
		let input_strings = ["0xabc123"];
		let _ = parse_public_inputs_from_snarkjs(&input_strings);
	}

	// === parse_proof_from_snarkjs Tests ===

	#[test]
	fn test_parse_proof_from_snarkjs_valid() {
		// Valid proof points from a real proof
		let proof_points = SnarkjsProofPoints {
			a_x: "19310665078306784406662215815651232366118953555532993625404293661707393313612",
			a_y: "11526666870423797426171768900087789746235310963851363013222396772078662171115",
			b_x0: "6010443894014200233438330038448044759571488627884631111958559202603979987992",
			b_x1: "19893187996136105803907318491959710717180097069680221139759473467891217377198",
			b_y0: "1793890726789761517579060243340680077348695067467741558973424433312717183077",
			b_y1: "8418746653214820419604605015564182122929427496727580773178512074941139353055",
			c_x: "19943346293308443045296477224123020528716829401937379717970359710082396275231",
			c_y: "17070758087329749108157075328504249625824445825715061802638610182418487497999",
		};

		let result = parse_proof_from_snarkjs(proof_points);
		assert!(result.is_ok(), "Should parse valid proof");

		let proof = result.unwrap();
		assert!(!proof.as_bytes().is_empty());
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_proof_invalid_a_x() {
		let proof_points = SnarkjsProofPoints {
			a_x: "invalid",
			a_y: "11526666870423797426171768900087789746235310963851363013222396772078662171115",
			b_x0: "6010443894014200233438330038448044759571488627884631111958559202603979987992",
			b_x1: "19893187996136105803907318491959710717180097069680221139759473467891217377198",
			b_y0: "1793890726789761517579060243340680077348695067467741558973424433312717183077",
			b_y1: "8418746653214820419604605015564182122929427496727580773178512074941139353055",
			c_x: "19943346293308443045296477224123020528716829401937379717970359710082396275231",
			c_y: "17070758087329749108157075328504249625824445825715061802638610182418487497999",
		};

		let _ = parse_proof_from_snarkjs(proof_points);
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_proof_invalid_b_coordinate() {
		let proof_points = SnarkjsProofPoints {
			a_x: "19310665078306784406662215815651232366118953555532993625404293661707393313612",
			a_y: "11526666870423797426171768900087789746235310963851363013222396772078662171115",
			b_x0: "invalid_coordinate",
			b_x1: "19893187996136105803907318491959710717180097069680221139759473467891217377198",
			b_y0: "1793890726789761517579060243340680077348695067467741558973424433312717183077",
			b_y1: "8418746653214820419604605015564182122929427496727580773178512074941139353055",
			c_x: "19943346293308443045296477224123020528716829401937379717970359710082396275231",
			c_y: "17070758087329749108157075328504249625824445825715061802638610182418487497999",
		};

		let _ = parse_proof_from_snarkjs(proof_points);
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_proof_invalid_c_y() {
		let proof_points = SnarkjsProofPoints {
			a_x: "19310665078306784406662215815651232366118953555532993625404293661707393313612",
			a_y: "11526666870423797426171768900087789746235310963851363013222396772078662171115",
			b_x0: "6010443894014200233438330038448044759571488627884631111958559202603979987992",
			b_x1: "19893187996136105803907318491959710717180097069680221139759473467891217377198",
			b_y0: "1793890726789761517579060243340680077348695067467741558973424433312717183077",
			b_y1: "8418746653214820419604605015564182122929427496727580773178512074941139353055",
			c_x: "19943346293308443045296477224123020528716829401937379717970359710082396275231",
			c_y: "",
		};

		let _ = parse_proof_from_snarkjs(proof_points);
	}

	// === Helper Function Tests ===

	#[test]
	fn test_parse_fq_valid() {
		let result = parse_fq("123");
		// Should not panic
		let _ = result;
	}

	#[test]
	fn test_parse_fq_zero() {
		let result = parse_fq("0");
		// Should successfully parse zero
		let _ = result;
	}

	#[test]
	fn test_parse_fq_large_value() {
		let result = parse_fq(
			"21888242871839275222246405745257275088548364400416034343698204186575808495616",
		);
		// Should handle large field values
		let _ = result;
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_fq_invalid() {
		let _ = parse_fq("not_a_number");
	}

	#[test]
	fn test_parse_fr_valid() {
		let result = parse_fr("456");
		// Should not panic
		let _ = result;
	}

	#[test]
	fn test_parse_fr_zero() {
		let result = parse_fr("0");
		// Should successfully parse zero
		let _ = result;
	}

	#[test]
	#[should_panic(expected = "Invalid field element string")]
	fn test_parse_fr_invalid() {
		let _ = parse_fr("invalid_input");
	}

	// === SnarkjsProofPoints Structure Test ===

	#[test]
	fn test_snarkjs_proof_points_construction() {
		let points = SnarkjsProofPoints {
			a_x: "1",
			a_y: "2",
			b_x0: "3",
			b_x1: "4",
			b_y0: "5",
			b_y1: "6",
			c_x: "7",
			c_y: "8",
		};

		assert_eq!(points.a_x, "1");
		assert_eq!(points.a_y, "2");
		assert_eq!(points.b_x0, "3");
		assert_eq!(points.b_x1, "4");
		assert_eq!(points.b_y0, "5");
		assert_eq!(points.b_y1, "6");
		assert_eq!(points.c_x, "7");
		assert_eq!(points.c_y, "8");
	}
}
