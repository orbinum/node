//! Snarkjs format parser
//!
//! This module provides utilities to parse proofs and public inputs from
//! the JSON format generated by snarkjs (the tool used to compile Circom circuits).

#[allow(unused_imports)]
use crate::core::{
	error::VerifierError,
	types::{Proof, PublicInputs},
};

#[cfg(feature = "std")]
use {
	ark_bn254::{Fq, Fq2, G1Affine, G2Affine},
	ark_ff::PrimeField,
	ark_groth16::Proof as ArkProof,
	num_bigint::BigUint,
};

/// Snarkjs proof points as separate coordinate strings
pub struct SnarkjsProofPoints<'a> {
	pub a_x: &'a str,
	pub a_y: &'a str,
	pub b_x0: &'a str,
	pub b_x1: &'a str,
	pub b_y0: &'a str,
	pub b_y1: &'a str,
	pub c_x: &'a str,
	pub c_y: &'a str,
}

/// Parse a proof from snarkjs JSON format
///
/// The snarkjs format looks like:
/// ```json
/// {
///   "a": { "x": "...", "y": "..." },
///   "b": { "x": ["...", "..."], "y": ["...", "..."] },
///   "c": { "x": "...", "y": "..." }
/// }
/// ```
#[cfg(feature = "std")]
pub fn parse_proof_from_snarkjs(points: SnarkjsProofPoints) -> Result<Proof, VerifierError> {
	use ark_bn254::Bn254;

	// Parse point A (G1)
	let a = G1Affine::new(parse_fq(points.a_x), parse_fq(points.a_y));

	// Parse point B (G2)
	// Note: snarkjs uses (x0, x1) order but arkworks might use (c1, c0)
	// We need to check the convention
	let b = G2Affine::new(
		Fq2::new(parse_fq(points.b_x0), parse_fq(points.b_x1)),
		Fq2::new(parse_fq(points.b_y0), parse_fq(points.b_y1)),
	);

	// Parse point C (G1)
	let c = G1Affine::new(parse_fq(points.c_x), parse_fq(points.c_y));

	// Create arkworks proof
	let ark_proof = ArkProof::<Bn254> { a, b, c };

	// Convert to our Proof type
	Proof::from_ark_proof(&ark_proof)
}

/// Parse public inputs from snarkjs JSON format
///
/// The format is an array of field element strings:
/// ```json
/// ["123...", "456...", ...]
/// ```
#[cfg(feature = "std")]
pub fn parse_public_inputs_from_snarkjs(
	input_strings: &[&str],
) -> Result<PublicInputs, VerifierError> {
	use ark_ff::{BigInteger, PrimeField};

	let inputs: Result<Vec<_>, _> = input_strings
		.iter()
		.map(|s| {
			let field = parse_fr(s);

			// Convert to bytes (big-endian)
			let mut bytes = [0u8; 32];
			let elem_bytes = field.into_bigint().to_bytes_be();
			let start = 32 - elem_bytes.len();
			bytes[start..].copy_from_slice(&elem_bytes);

			Ok(bytes)
		})
		.collect();

	Ok(PublicInputs::new(inputs?))
}

#[cfg(feature = "std")]
fn parse_fq(s: &str) -> Fq {
	let bigint = BigUint::parse_bytes(s.as_bytes(), 10).expect("Invalid field element string");

	let bytes = bigint.to_bytes_le();
	let mut bytes_32 = [0u8; 32];
	bytes_32[..bytes.len().min(32)].copy_from_slice(&bytes[..bytes.len().min(32)]);

	Fq::from_le_bytes_mod_order(&bytes_32)
}

#[cfg(feature = "std")]
fn parse_fr(s: &str) -> ark_bn254::Fr {
	let bigint = BigUint::parse_bytes(s.as_bytes(), 10).expect("Invalid field element string");

	let bytes = bigint.to_bytes_le();
	let mut bytes_32 = [0u8; 32];
	bytes_32[..bytes.len().min(32)].copy_from_slice(&bytes[..bytes.len().min(32)]);

	ark_bn254::Fr::from_le_bytes_mod_order(&bytes_32)
}
